{
    "task_id": "0ace46bc-2345-4e70-95b9-9502b5a4d1dc",
    "model": "unsloth/SmolLM2-1.7B",
    "dataset": "https://gradients.s3.eu-north-1.amazonaws.com/18c63d6ca57b7239_test_data.json?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVVZOOA7SA4UOFLPI%2F20251016%2Feu-north-1%2Fs3%2Faws4_request&X-Amz-Date=20251016T100013Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=940ca5c80bc9ca449bd36b985f2d4cff249fc42328a7c79f2167a2255e5742e1",
    "dataset_type": {
      "field_prompt": "prompt",
      "reward_functions": [
        {
          "reward_id": "2226678e-df0d-42d0-8adb-551aec0ed88e",
          "reward_func": "def sat_reward_function(completions, extra_data=None, **kwargs):\n    \"\"\"\n    SAT (Boolean Satisfiability) reward function with partial credit.\n\n    Returns percentage of clauses satisfied for each completion.\n    Expects extra_data with task_type='SAT' and 'cls' field.\n    \"\"\"\n    import re\n    import json\n    extra_data_list = extra_data if extra_data is not None else kwargs.get(\n        'extra_data', [])\n    if not extra_data_list:\n        return [0.0] * len(completions)\n    if isinstance(extra_data_list, dict):\n        extra_data_list = [extra_data_list] * len(completions)\n    elif len(extra_data_list) == 1 and len(completions) > 1:\n        extra_data_list = extra_data_list * len(completions)\n    scores = []\n    for completion, extra_data_item in zip(completions, extra_data_list):\n        if isinstance(extra_data_item, str):\n            try:\n                extra_data_item = json.loads(extra_data_item)\n            except json.JSONDecodeError:\n                scores.append(0.0)\n                continue\n        if not isinstance(extra_data_item, dict):\n            scores.append(0.0)\n            continue\n        if extra_data_item.get('task_type', '').upper() != 'SAT':\n            scores.append(0.0)\n            continue\n        cls = extra_data_item.get('cls', [])\n        if not isinstance(cls, list):\n            scores.append(0.0)\n            continue\n        try:\n            if not cls:\n                scores.append(0.0)\n                continue\n            assignments = {}\n            for match in re.findall('x(\\\\d+)\\\\s*=\\\\s*(True|False|1|0)', str\n                (completion), re.IGNORECASE):\n                var_num = int(match[0])\n                value = match[1].lower() in ('true', '1')\n                assignments[var_num] = value\n            if not assignments:\n                scores.append(0.0)\n                continue\n            satisfied_count = 0\n            for clause in cls:\n                if not isinstance(clause, list):\n                    continue\n                clause_satisfied = False\n                for literal in clause:\n                    var = abs(int(literal))\n                    is_positive = literal > 0\n                    if var in assignments:\n                        if is_positive and assignments[var\n                            ] or not is_positive and not assignments[var]:\n                            clause_satisfied = True\n                            break\n                if clause_satisfied:\n                    satisfied_count += 1\n            score = satisfied_count / len(cls) if cls else 0.0\n            scores.append(score)\n        except Exception:\n            scores.append(0.0)\n    return scores\n",
          "reward_weight": 0.3333333333333333,
          "func_hash": "ed24ba0b3a1f16bd61643ba57e20225d026296c5702c51e365df2d961d5670db",
          "is_generic": false,
          "is_manual": true
        },
        {
          "reward_id": "b5008828-8628-4ef5-b3f2-f77580028b67",
          "reward_func": "def ded_reward_function(completions, extra_data=None, **kwargs):\n    \"\"\"Partial credit reward function for DED problems\"\"\"\n\n    def restricted_execution(code: str, input_data: str) ->tuple[str, str]:\n        \"\"\"Execute Python code with RestrictedPython restrictions.\n    \n    Args:\n        code: Python code to execute\n        input_data: Input data to pass to the code\n        \n    Returns:\n        Tuple of (output, error) where output is stdout and error is stderr\n    \"\"\"\n        import contextlib\n        import io\n        from RestrictedPython import compile_restricted\n        from RestrictedPython.Guards import safe_builtins\n        from RestrictedPython.Guards import safe_globals\n        from RestrictedPython.PrintCollector import PrintCollector\n        stderr_capture = io.StringIO()\n        try:\n            compiled_code = compile_restricted(code, '<string>', 'exec')\n            if compiled_code is None:\n                return '', 'Failed to compile restricted code'\n            restricted_builtins = safe_builtins.copy()\n            extra_builtins = {'sum': sum, 'min': min, 'max': max, 'abs':\n                abs, 'round': round, 'sorted': sorted, 'reversed': reversed,\n                'enumerate': enumerate, 'zip': zip, 'map': map, 'filter':\n                filter}\n            for name, func in extra_builtins.items():\n                restricted_builtins[name] = func\n            input_lines = input_data.split('\\n') if input_data else []\n\n            def create_input_func(lines):\n                lines_iter = iter(lines)\n\n                def input_func(prompt=''):\n                    try:\n                        return next(lines_iter)\n                    except StopIteration:\n                        return ''\n                return input_func\n            restricted_globals = {'__builtins__': restricted_builtins,\n                '_print_': PrintCollector, '_getattr_': getattr,\n                '_getitem_': lambda obj, key: obj[key], '_getiter_': iter,\n                'input': create_input_func(input_lines), 'sum': sum, 'min':\n                min, 'max': max, 'enumerate': enumerate, 'map': map,\n                'filter': filter, 'list': list, 'dict': dict, 'str': str,\n                'int': int, 'float': float, 'bool': bool, 'len': len,\n                'range': range}\n            restricted_globals.update(safe_globals)\n            local_vars = {}\n            with contextlib.redirect_stderr(stderr_capture):\n                exec(compiled_code, restricted_globals, local_vars)\n            print_collector = local_vars.get('_print')\n            if print_collector and hasattr(print_collector, 'txt'):\n                output = '\\n'.join(str(item) for item in print_collector.txt)\n            else:\n                output = ''\n            error = stderr_capture.getvalue()\n            return output, error\n        except Exception as e:\n            return '', str(e)\n    \"\"\"\n    DED (Deductive/Code) reward function with partial credit.\n\n    Returns 1.0 for correct output, partial credit for valid syntax/execution.\n    Expects extra_data with task_type='DED', 'solution', and 'premises'.\n    Uses restricted_execution for safe code execution.\n    \"\"\"\n    import re\n    import json\n    extra_data_list = extra_data if extra_data is not None else kwargs.get(\n        'extra_data', [])\n    if not extra_data_list:\n        return [0.0] * len(completions)\n    if isinstance(extra_data_list, dict):\n        extra_data_list = [extra_data_list] * len(completions)\n    elif len(extra_data_list) == 1 and len(completions) > 1:\n        extra_data_list = extra_data_list * len(completions)\n    scores = []\n    for completion, extra_data_item in zip(completions, extra_data_list):\n        if isinstance(extra_data_item, str):\n            try:\n                extra_data_item = json.loads(extra_data_item)\n            except json.JSONDecodeError:\n                scores.append(0.0)\n                continue\n        if not isinstance(extra_data_item, dict):\n            scores.append(0.0)\n            continue\n        if extra_data_item.get('task_type', '').upper() != 'DED':\n            scores.append(0.0)\n            continue\n        solution = extra_data_item.get('solution', '')\n        premises = extra_data_item.get('premises', [])\n        if not solution:\n            scores.append(0.0)\n            continue\n        try:\n            fence_pattern = re.compile('```(?:python)?\\\\s*([\\\\s\\\\S]*?)```',\n                re.IGNORECASE)\n            match = fence_pattern.search(str(completion))\n            if not match:\n                if any(keyword in str(completion) for keyword in ['def ',\n                    'print', 'input', 'return']):\n                    scores.append(0.1)\n                else:\n                    scores.append(0.0)\n                continue\n            submitted_code = match.group(1).strip()\n            try:\n                compile(submitted_code, '<string>', 'exec')\n            except:\n                scores.append(0.2)\n                continue\n            sol_match = fence_pattern.search(solution)\n            if sol_match:\n                solution = sol_match.group(1).strip()\n            if not premises or not isinstance(premises, list):\n                scores.append(0.3)\n                continue\n            test_input = str(premises[0]) if premises else ''\n            expected_output, expected_error = restricted_execution(solution,\n                test_input)\n            if expected_error:\n                scores.append(0.35)\n                continue\n            actual_output, actual_error = restricted_execution(submitted_code,\n                test_input)\n            if actual_error:\n                scores.append(0.4)\n                continue\n            expected_clean = '\\n'.join(line.rstrip() for line in\n                expected_output.strip().splitlines())\n            actual_clean = '\\n'.join(line.rstrip() for line in\n                actual_output.strip().splitlines())\n            if expected_clean == actual_clean:\n                scores.append(1.0)\n            elif expected_clean in actual_clean or actual_clean in expected_clean:\n                scores.append(0.8)\n            else:\n                scores.append(0.5)\n        except Exception:\n            scores.append(0.0)\n    return scores\n",
          "reward_weight": 0.3333333333333333,
          "func_hash": "f6bd68c2728babbc8dec0841739eb65dced6cb7d52835058879d5c1c397f9836",
          "is_generic": false,
          "is_manual": true
        },
        {
          "reward_id": "dadf301b-14cc-4bb2-9bb8-7d658d29661c",
          "reward_func": "def abd_reward_function(completions, extra_data=None, **kwargs):\n    \"\"\"Partial credit reward function for ABD problems\"\"\"\n\n    def restricted_execution(code: str, input_data: str) ->tuple[str, str]:\n        \"\"\"Execute Python code with RestrictedPython restrictions.\n    \n    Args:\n        code: Python code to execute\n        input_data: Input data to pass to the code\n        \n    Returns:\n        Tuple of (output, error) where output is stdout and error is stderr\n    \"\"\"\n        import contextlib\n        import io\n        from RestrictedPython import compile_restricted\n        from RestrictedPython.Guards import safe_builtins\n        from RestrictedPython.Guards import safe_globals\n        from RestrictedPython.PrintCollector import PrintCollector\n        stderr_capture = io.StringIO()\n        try:\n            compiled_code = compile_restricted(code, '<string>', 'exec')\n            if compiled_code is None:\n                return '', 'Failed to compile restricted code'\n            restricted_builtins = safe_builtins.copy()\n            extra_builtins = {'sum': sum, 'min': min, 'max': max, 'abs':\n                abs, 'round': round, 'sorted': sorted, 'reversed': reversed,\n                'enumerate': enumerate, 'zip': zip, 'map': map, 'filter':\n                filter}\n            for name, func in extra_builtins.items():\n                restricted_builtins[name] = func\n            input_lines = input_data.split('\\n') if input_data else []\n\n            def create_input_func(lines):\n                lines_iter = iter(lines)\n\n                def input_func(prompt=''):\n                    try:\n                        return next(lines_iter)\n                    except StopIteration:\n                        return ''\n                return input_func\n            restricted_globals = {'__builtins__': restricted_builtins,\n                '_print_': PrintCollector, '_getattr_': getattr,\n                '_getitem_': lambda obj, key: obj[key], '_getiter_': iter,\n                'input': create_input_func(input_lines), 'sum': sum, 'min':\n                min, 'max': max, 'enumerate': enumerate, 'map': map,\n                'filter': filter, 'list': list, 'dict': dict, 'str': str,\n                'int': int, 'float': float, 'bool': bool, 'len': len,\n                'range': range}\n            restricted_globals.update(safe_globals)\n            local_vars = {}\n            with contextlib.redirect_stderr(stderr_capture):\n                exec(compiled_code, restricted_globals, local_vars)\n            print_collector = local_vars.get('_print')\n            if print_collector and hasattr(print_collector, 'txt'):\n                output = '\\n'.join(str(item) for item in print_collector.txt)\n            else:\n                output = ''\n            error = stderr_capture.getvalue()\n            return output, error\n        except Exception as e:\n            return '', str(e)\n    \"\"\"\n    ABD (Algorithmic Backward Design) reward function with partial credit.\n\n    Returns 1.0 for exact match, partial credit for close outputs.\n    Expects extra_data with task_type='ABD', 'program', and 'expected_output'.\n    Uses restricted_execution for safe code execution.\n    \"\"\"\n    import re\n    import json\n    extra_data_list = extra_data if extra_data is not None else kwargs.get(\n        'extra_data', [])\n    if not extra_data_list:\n        return [0.0] * len(completions)\n    if isinstance(extra_data_list, dict):\n        extra_data_list = [extra_data_list] * len(completions)\n    elif len(extra_data_list) == 1 and len(completions) > 1:\n        extra_data_list = extra_data_list * len(completions)\n    scores = []\n    for completion, extra_data_item in zip(completions, extra_data_list):\n        if isinstance(extra_data_item, str):\n            try:\n                extra_data_item = json.loads(extra_data_item)\n            except json.JSONDecodeError:\n                scores.append(0.0)\n                continue\n        if not isinstance(extra_data_item, dict):\n            scores.append(0.0)\n            continue\n        if extra_data_item.get('task_type', '').upper() != 'ABD':\n            scores.append(0.0)\n            continue\n        program = extra_data_item.get('program', '')\n        expected_output = extra_data_item.get('expected_output', '')\n        if not program:\n            scores.append(0.0)\n            continue\n        try:\n            fence_pattern = re.compile('```(?:python)?\\\\s*([\\\\s\\\\S]*?)```',\n                re.IGNORECASE)\n            match = fence_pattern.search(program)\n            if match:\n                program = match.group(1).strip()\n            response = str(completion)\n            response = re.sub('<think>.*?</think>', '', response, flags=re.\n                DOTALL)\n            response = re.sub('<thinking>.*?</thinking>', '', response,\n                flags=re.DOTALL)\n            input_matches = re.findall('<INPUT>(.*?)</INPUT>', response, re\n                .IGNORECASE | re.DOTALL)\n            if not input_matches:\n                if '<INPUT' in response.upper():\n                    scores.append(0.1)\n                else:\n                    scores.append(0.0)\n                continue\n            generated_input = input_matches[-1].strip()\n            lines = [ln.rstrip() for ln in generated_input.splitlines()]\n            while lines and not lines[-1].strip():\n                lines.pop()\n            generated_input = '\\n'.join(lines)\n            output, error = restricted_execution(program, generated_input)\n            if error:\n                scores.append(0.2)\n                continue\n            output_clean = '\\n'.join(line.rstrip() for line in output.strip\n                ().splitlines())\n            expected_clean = '\\n'.join(line.rstrip() for line in str(\n                expected_output).strip().splitlines())\n            if output_clean == expected_clean:\n                scores.append(1.0)\n            elif not output_clean or not expected_clean:\n                scores.append(0.3)\n            else:\n                matches = sum(c1 == c2 for c1, c2 in zip(output_clean,\n                    expected_clean))\n                similarity = matches / max(len(output_clean), len(\n                    expected_clean))\n                scores.append(min(0.3 + 0.6 * similarity, 0.95))\n        except Exception:\n            scores.append(0.0)\n    return scores\n",
          "reward_weight": 0.3333333333333333,
          "func_hash": "68e2ff31e4a10a6a5aa4391907573f4284e42767f2332b9dd46b439a6ed028b6",
          "is_generic": false,
          "is_manual": true
        }
      ]
    },
    "extra_column": "extra_data",
    "task_type": "GrpoTask",
    "file_format": "s3",
    "expected_repo_name": "0ace46bc-2345-4e70-95b9-9502b5a4d1dc",
    "hours_to_complete": 1,
    "gpu_ids": [0]
  }